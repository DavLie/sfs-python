"""Compute the sound field generated by a sound source"""

import itertools
import numpy as np
from scipy import special
from .. import util


def point(omega, x0, n0, grid, c=None):
    """Point source.

    ::

                    1  e^(-j w/c |x-x0|)
      G(x-x0, w) = --- -----------------
                   4pi      |x-x0|

    """
    k = util.wavenumber(omega, c)
    x0 = util.asarray_1d(x0)
    grid = util.asarray_of_arrays(grid)

    r = np.linalg.norm(grid - x0)
    return np.squeeze(1/(4*np.pi) * np.exp(-1j * k * r) / r)


def point_modal(omega, x0, n0, grid, L, N=None, deltan=0, c=None):
    """Point source in a rectangular room using a modal room model.

    Parameters
    ----------
    omega : float
        Frequency of source.
    x0 : triple of floats
        Position of source.
    n0 : triple of floats
        Normal vector (direction) of source (only required for compatibility).
    grid : list of numpy.ndarrays
        The grid that is used for the sound field calculations.
    L : triple of floats
        Dimensionons of the rectangular room.
    N : triple of integers or integer
        Combination of modal orders in the three-spatial dimensions to
        calculate the sound field for or maximum order for all dimensions.
        If not given, the maximum modal order is approximately determined and
        the sound field is computed up to this maximum order.
    deltan : float
        Absorption coefficient of the walls.
    c : float
        Speed of sound.

    Returns
    -------
    p : array of floats
        Sound pressure at positions given by grid

    """
    k = util.wavenumber(omega, c)
    x0 = util.asarray_1d(x0)
    x, y, z = util.asarray_of_arrays(grid)

    if N is None:
        # determine maximum modal order per dimension
        Nx = int(np.ceil(L[0]/np.pi * k))
        Ny = int(np.ceil(L[1]/np.pi * k))
        Nz = int(np.ceil(L[2]/np.pi * k))
        mm = range(Nx)
        nn = range(Ny)
        ll = range(Nz)
    elif np.isscalar(N):
        # compute up to a given order
        mm = range(N)
        nn = range(N)
        ll = range(N)
    else:
        # compute field for one order combination only
        mm = [N[0]]
        nn = [N[1]]
        ll = [N[2]]

    kmp0 = [((kx + 1j * deltan)**2, np.cos(kx * x) * np.cos(kx * x0[0]))
            for kx in [m * np.pi / L[0] for m in mm]]
    kmp1 = [((ky + 1j * deltan)**2, np.cos(ky * y) * np.cos(ky * x0[1]))
            for ky in [n * np.pi / L[1] for n in nn]]
    kmp2 = [((kz + 1j * deltan)**2, np.cos(kz * z) * np.cos(kz * x0[2]))
            for kz in [l * np.pi / L[2] for l in ll]]
    ksquared = k**2
    p = 0
    for (km0, p0), (km1, p1), (km2, p2) in itertools.product(kmp0, kmp1, kmp2):
        km = km0 + km1 + km2
        p = p + 1 / (ksquared - km) * p0 * p1 * p2

    return np.squeeze(p)


def line(omega, x0, n0, grid, c=None):
    """Line source parallel to the z-axis.

    Note: third component of x0 is ignored.

    ::

                         (2)
      G(x-x0, w) = -j/4 H0  (w/c |x-x0|)

    """
    k = util.wavenumber(omega, c)
    x0 = util.asarray_1d(x0)
    x0 = x0[:2]  # ignore z-component
    grid = util.asarray_of_arrays(grid)

    r = np.linalg.norm(grid[:2] - x0)
    p = -1j/4 * special.hankel2(0, k * r)
    p = _duplicate_zdirection(p, grid)
    return np.squeeze(p)


def line_dipole(omega, x0, n0, grid, c=None):
    """Line source with dipole characteristics parallel to the z-axis.

    Note: third component of x0 is ignored.

    ::

                         (2)
      G(x-x0, w) = jk/4 H1  (w/c |x-x0|) cos(phi)


    """
    k = util.wavenumber(omega, c)
    x0 = util.asarray_1d(x0)
    x0 = x0[:2]  # ignore z-component
    n0 = n0[:2]
    grid = util.asarray_of_arrays(grid)
    dx = grid[:2] - x0
    r = np.linalg.norm(dx)
    p = 1j*k/4 * special.hankel2(1, k * r) * np.inner(dx, n0) / r
    p = _duplicate_zdirection(p, grid)
    return np.squeeze(p)


def plane(omega, x0, n0, grid, c=None):
    """Plane wave.

    ::

      G(x, w) = e^(-i w/c n x)

    """
    k = util.wavenumber(omega, c)
    x0 = util.asarray_1d(x0)
    n0 = util.asarray_1d(n0)
    grid = util.asarray_of_arrays(grid)

    return np.squeeze(np.exp(-1j * k * np.inner(grid - x0, n0)))


def _duplicate_zdirection(p, grid):
    """If necessary, duplicate field in z-direction"""
    gridshape = np.broadcast(*grid).shape
    if len(gridshape) > 2:
        return np.tile(p, [1, 1, gridshape[2]])
    else:
        return p
